# Batch runs

These tests illustrate batch run behavior. We'll use the `batch`
sample project:

    >>> project = sample("projects", "batch")

We'll run everything in a temp Guild home:

    >>> guild_home = mkdtemp()

And a helper for running ops:

    >>> from guild import _api as gapi
    >>> def run(op, **flags):
    ...   try:
    ...     output = gapi.run_capture_output(
    ...       op, cwd=project, flags=flags,
    ...       guild_home=guild_home)
    ...   except gapi.RunError as e:
    ...     print("ERROR (%i)" % e.returncode)
    ...     print(e.output)
    ...   else:
    ...     print(output.strip())

And a helper for listing runs:

    >>> from guild import cli
    >>> from guild.op_util import format_flag_val

    >>> def list_runs(**kw):
    ...   runs = gapi.runs_list(guild_home=guild_home, **kw)
    ...   table_data = []
    ...   flag_names = set()
    ...   for run in runs:
    ...     row_data = {"op": run.opref.to_opspec()}
    ...     table_data.append(row_data)
    ...     for name, val in run.get("flags", {}).items():
    ...       row_data[name] = "%s=%s" % (name, format_flag_val(val))
    ...       flag_names.add(name)
    ...   cli.table(table_data, ["op"] + sorted(flag_names))

And a helper to delete runs:

    >>> def delete_runs(runs=None):
    ...   gapi.runs_delete(runs, guild_home=guild_home)

We start with no runs:

    >>> list_runs()

## Batch runs

A batch run is a run that contains either explicit or implicit batch
specifiers.

Batch runs generate one or more trial runs.

There are two types of implicit batch specifiers:

- Flag list value
- A batch file

A flag list value indicates that the operation should be run each
value in the list. If there is more tha one flag with list values, the
operation is run over the catesian produce of all a possible flag
combinations.

A batch file may contain one or more flag combinations, each of which
is used to run the operation.

If both flag list values and batch files are used, the flag values are
applied to each flag combination in the batch files.

An explicit batch specifier is made using the `--optimizer` flag,
which indicates that the specified optimizer should be used to run the
operation multiple times with the goal of minimizing or maximizing an
operation result.

We'll look at each of these scanarios in the tests that follow.

## Baseline

We'll two operations to illustate various batch runs.

The first is the `say.py` script, which simply prints a specified
message, optionally capitalizing it.

    >>> run("say.py")
    hello

    >>> run("say.py", msg="hi")
    hi

    >>> run("say.py", msg="hi", loud="yes")
    HI

And our runs:

    >>> list_runs()
    say.py  loud=yes  msg=hi
    say.py  loud=no   msg=hi
    say.py  loud=no   msg=hello

TODO: show baseline for optimizing operation (e.g. copy over the
train.py op from the Guild optimizer example).

Let's delete our runs in preparation for the next section.

    >>> delete_runs()
    Deleted 3 run(s)

## Flag list values

A batch is run impicitly whenever a list of values is specified for a
flag.

Let's run `say.py` with a list of one `msg` flag value:

    >>> run("say.py", msg=["hi"])
    INFO: [guild] Running say.py (loud=no, msg=hi)
    hi

Here are the trial runs:

    >>> list_runs()
    say.py   loud=no  msg=hi
    +say.py

Note there are two runs. The first run, listed as `+say.py` (note the
leading plus sign), is the batch operation, which is separate from the
trial run.

The batch operation manages the trial runs. Failed batch operations,
for example, can be restarted by restarting the associated runs.

    >>> delete_runs()
    Deleted 2 run(s)

Next we'll run `say.py` with two values for `msg`:

    >>> run("say.py", msg=["hello", "hola"])
    INFO: [guild] Running say.py (loud=no, msg=hello)
    hello
    INFO: [guild] Running say.py (loud=no, msg=hola)
    hola

In this case, we have three runs, one for the batch and two for each
trial.

    >>> list_runs()
    say.py   loud=no  msg=hola
    say.py   loud=no  msg=hello
    +say.py

Here we we see that two trials are generated by the batch, each with
one of the specified `msg` flag values.

Trials are run in order corresponding to the flag value in the
list.

    >>> run("say.py", msg=["c", "a", "b"])
    INFO: [guild] Running say.py (loud=no, msg=c)
    c
    INFO: [guild] Running say.py (loud=no, msg=a)
    a
    INFO: [guild] Running say.py (loud=no, msg=b)
    b

We can specify other flags along with our batch specifiers:

    >>> run("say.py", msg=["a", "b"], loud="yes")
    INFO: [guild] Running say.py (loud=yes, msg=a)
    A
    INFO: [guild] Running say.py (loud=yes, msg=b)
    B

If we use multiple list values, trials are generated using the
cartesian product of all flag combinations. The order of trials
corresponds to the flag names in ascending order followed by the flag
values as ordered in each flag value list.

    >>> run("say.py", msg=["b", "a"], loud=["no", "yes"])
    INFO: [guild] Running say.py (loud=no, msg=b)
    b
    INFO: [guild] Running say.py (loud=no, msg=a)
    a
    INFO: [guild] Running say.py (loud=yes, msg=b)
    B
    INFO: [guild] Running say.py (loud=yes, msg=a)
    A
