# Operation steps

Operations may be defined using a sequence of steps, rather than a
main or exec spec.

We'll use the sample project 'steps' to illustrate the behavior.

    >>> project = sample("projects", "steps")

Here's the project Guild file:

    >>> from guild import guildfile
    >>> gf = guildfile.from_dir(project)

Here are the suported models:

    >>> pprint(gf.models)
    {'m1': <guild.guildfile.ModelDef 'm1'>,
     'm2': <guild.guildfile.ModelDef 'm2'>,
     'm3': <guild.guildfile.ModelDef 'm3'>}

For our tests, we'll use an alternative Guild home location:

    >>> home = mkdtemp()

We'll use the experimental `_api` interface to run operations:

    >>> from guild import _api as gapi

Some helper functions:

    >>> def run_op(op_spec, **flags):
    ...   try:
    ...     output = gapi.run_capture_output(
    ...       op_spec,
    ...       flags=flags,
    ...       cwd=project,
    ...       guild_home=home)
    ...   except gapi.RunError as e:
    ...     print("ERROR (%i)" % e.returncode)
    ...     print(e.output)
    ...   else:
    ...     print(output)

    >>> def runs_list():
    ...   return gapi.runs_list(guild_home=home)

    >>> def print_runs(runs):
    ...   for run in runs:
    ...     print(run.opref.to_opspec())

Testing our interface:

    >>> runs_list()
    []

## Basic steps

Steps are stored as the operation `steps` attribute. They are no
processed by the Guild file as they are merely passed through to
`guild.steps_main` by way of the `steps` run attribute.

Here are the steps for `m1:steps-basic`.

    >>> gf.models["m1"].get_operation("steps-basic").steps
    ['step-1', 'step-2']

Note that the raw data structure is provided rather than any higher
level structured data.

The `steps-basic` operation runs the two operations in the order
specified.

    >>> run_op("m1:steps-basic")
    INFO: [guild] running step-1: m1:step-1
    hello step-1
    INFO: [guild] running step-2: m1:step-2
    hello step-2

In this case, three runs are generated:

    >>> runs = runs_list()
    >>> print_runs(runs)
    m1:step-2
    m1:step-1
    m1:steps-basic

Here we see that by running `steps-basic`, we generated runs for
`step-1` and `step-2`.

Each run generated by a step is a normal Guild run.

Here are the files generated for `step-1` and `step-2`:

    >>> dir(runs[0].path)
    ['.guild', 'step-2']

    >>> dir(runs[1].path)
    ['.guild', 'step-1']

The stepped run `steps-basic` contains symbolic links to the two
genated runs:

    >>> dir(runs[2].path)
    ['.guild', 'step-1', 'step-2']

    >>> step1_target = basename(realpath(join_path(runs[2].path, "step-1")))
    >>> step1_target == runs[1].id, (step1_target, runs[1].id)
    (True, ...)

    >>> step2_target = basename(realpath(join_path(runs[2].path, "step-2")))
    >>> step2_target == runs[0].id, (step1_target, runs[0].id)
    (True, ...)

## Named steps

Steps can be named, which specifies the name of the link to
create. Names are also used when referring to the step.

The `steps-named` operation illustrates how names are used.

    >>> run_op("m1:steps-named")
    INFO: [guild] running s1: m1:step-1
    hello step-1
    INFO: [guild] running s2: m1:step-2
    hello step-2

Here are the last three runs generated:

    >>> runs = runs_list()[:3]
    >>> print_runs(runs)
    m1:step-2
    m1:step-1
    m1:steps-named

The links generated in the stepped run reflect the step names:

The stepped run `steps-basic` contains symbolic links to the two
genated runs:

    >>> dir(runs[2].path)
    ['.guild', 's1', 's2']

    >>> s1_target = basename(realpath(join_path(runs[2].path, "s1")))
    >>> s1_target == runs[1].id, (s1_target, runs[1].id)
    (True, ...)

    >>> s2_target = basename(realpath(join_path(runs[2].path, "s2")))
    >>> s2_target == runs[0].id, (s1_target, runs[0].id)
    (True, ...)

## Repeated steps

If a step is run more than once, the link names for subsequent runs
use an incrementing suffix to avoid name collisions.

    >>> run_op("m1:steps-repeat")
    INFO: [guild] running step-1: m1:step-1
    hello step-1
    INFO: [guild] running step-1: m1:step-1
    hello step-1
    INFO: [guild] running step-1: m1:step-1
    hello step-1

    >>> runs = runs_list()[:4]
    >>> print_runs(runs)
    m1:step-1
    m1:step-1
    m1:step-1
    m1:steps-repeat

    >>> dir(runs[3].path)
    ['.guild', 'step-1', 'step-1_2', 'step-1_3']

## Stepped operations and flags

Stepped operations may contain flags like any other operation. In the
case of a stepped operation, however, flags are used as arguments to
the operations they run.

We'll illustrate using `hello`, which is an operation that prints a
message specified with the `msg` flag, which defaults to 'hello
world':

    >>> run_op("m1:hello")
    hello world

And with an explicit message:

    >>> run_op("m1:hello", msg="hello from test")
    hello from test

The `steps-hello` operation is a stepped operation that runs `hello`
twice. It defines its own flag `msg`, which defaults to 'hello steps',
and passes that flag value through to its steps.

Here's the default behavior of `steps-hello`:

    >>> run_op("m1:steps-hello")
    INFO: [guild] running hello: m1:hello 'msg=hello steps'
    hello steps
    INFO: [guild] running hello: m1:hello 'msg=hello steps (again)'
    hello steps (again)

And with an explicit message:

    >>> run_op("m1:steps-hello", msg="hello from test")
    INFO: [guild] running hello: m1:hello 'msg=hello from test'
    hello from test
    INFO: [guild] running hello: m1:hello 'msg=hello from test (again)'
    hello from test (again)

If a flag value is None/null, the flag is not passed through, in which
case the default value of the step operation is used:

    >>> run_op("m1:steps-hello", msg=None)
    INFO: [guild] running hello: m1:hello
    hello world
    INFO: [guild] running hello: m1:hello 'msg=null (again)'
    null (again)

## Running operations across models

A stepped operation may run operations defined in other models. Model
`m2` illustrates this with the `composite` operation.

    >>> run_op("m2:composite")
    INFO: [guild] running hello: m2:hello 'msg=hello m2, from composite'
    hello m2, from composite
    INFO: [guild] running m1:hello: m1:hello 'msg=hello m1, from composite'
    hello m1, from composite

And with a `name` flag:

    >>> run_op("m2:composite", name="test")
    INFO: [guild] running hello: m2:hello 'msg=hello m2, from test'
    hello m2, from test
    INFO: [guild] running m1:hello: m1:hello 'msg=hello m1, from test'
    hello m1, from test

## Invalid steps

Step config is validated while running the stepped operation, so
invalid step configuration will cause the stepper operation to fail
with an error.

The `m3` model contains various operations that have invalid step
configuration.

    >>> run_op("m3:steps-invalid-no-steps")
    ERROR (1)
    main_bootstrap.py: operation 'm3:steps-invalid-no-steps' is not valid:
    requires one of: main, exec, steps

    >>> run_op("m3:steps-invalid-bad-type")
    ERROR (1)
    guild: invalid steps data 123: expected list

    >>> run_op("m3:steps-invalid-bad-opspec-1")
    ERROR (1)
    guild: invalid step data: [1, 2, 3]

    >>> run_op("m3:steps-invalid-bad-opspec-2")
    ERROR (1)
    guild: invalid step data: None

    >>> run_op("m3:steps-invalid-bad-opspec-3")
    ERROR (1)
    guild: invalid step {'run': '   '}: must define run

    >>> run_op("m3:steps-invalid-bad-opspec-4")
    ERROR (1)
    guild: invalid step {}: must define run

    >>> run_op("m3:steps-invalid-bad-op")
    ERROR (1)
    INFO: [guild] running not-defined: m3:not-defined
    main_bootstrap.py: operation 'not-defined' is not defined for model 'm3'
    Try 'guild operations m3' for a list of available operations.

At the moment, steps do not support additional run options and any
provided will cause Guild to print a warning message.

    >>> run_op("m3:ignored-params")
    WARNING: [guild] run parameter remote used in 'm1:hello --run-dir /tmp --remote foo' ignored
    WARNING: [guild] run parameter run_dir used in 'm1:hello --run-dir /tmp --remote foo' ignored
    INFO: [guild] running m1:hello: m1:hello
    hello world
