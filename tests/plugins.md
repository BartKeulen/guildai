# Plugins

Plugin support is providedy by `guild.plugin`:

    >>> import guild.plugin

We need to explicitly initialize plugins by calling `init_plugins`:

    >>> guild.plugin.init_plugins()

## Enumerating plugins

Use `iter_plugins` to iterate through the list of available plugins:

    >>> sorted(guild.plugin.iter_plugins())
    [('cpu', <guild.plugins.cpu.CPUPlugin object ...>),
     ('disk', <guild.plugins.disk.DiskPlugin object ...>),
     ('gpu', <guild.plugins.gpu.GPUPlugin object ...>),
     ('keras', <guild.plugins.keras.KerasPlugin object ...>),
     ('memory', <guild.plugins.memory.MemoryPlugin object ...>)]

## Plugin instances

You can get the plugin instance using `for_name`:

    >>> guild.plugin.for_name("gpu")
    <guild.plugins.gpu.GPUPlugin object ...>

There is only ever one plugin instance for a given name:

    >>> guild.plugin.for_name("gpu") is guild.plugin.for_name("gpu")
    True

## Plugin helpers

### Listen method

Plugins routinely patch the environment to perform additional
actions. One such patch is to listen for method calls on various
classes. The `listen_method` function can be used to reveive
notification when a method is called.

Let's create a class with a method that prints a message:

    >>> class Hello(object):
    ...   def say(self, msg):
    ...     print(msg)

Let's patch `say`:

    >>> def wrap_say(say, msg):
    ...   say("I've wrapped '%s'" % msg)
    >>> guild.plugin.listen_method(Hello.say, wrap_say)

When we call `hello` on an object:

    >>> hello = Hello()
    >>> hello.say("Hello Guild!")
    I've wrapped 'Hello Guild!'
    Hello Guild!

The arg `say` is the original wrapped function, which can be called by
the wrapping function.

We can wrap a method multiple times. In this case we'll wrap using an
instance method:

    >>> class Wrapper(object):
    ...   def __init__(self, method):
    ...     guild.plugin.listen_method(method, self.wrap_say)
    ...
    ...   def wrap_say(self, say, msg):
    ...     say("I've also wrapped '%s'" % msg)

    >>> wrapper = Wrapper(Hello.say)
    >>> hello.say("Hello again!")
    I've wrapped 'Hello again!'
    I've also wrapped 'Hello again!'
    Hello again!

A wrapper can prevent the call to the wrapped function by returning
False.

    >>> def wrap_and_prevent(say, msg):
    ...   say("I've wrapped '%s' and prevented the original call!" % msg)
    ...   return False
    >>> guild.plugin.listen_method(Hello.say, wrap_and_prevent)
    >>> hello.say("Hello once more!")
    I've wrapped 'Hello once more!'
    I've also wrapped 'Hello once more!'
    I've wrapped 'Hello once more!' and prevented the original call!

Any errors generated by a wrapper are logged and isolated. Let's
illustrate by creating a wrapper that generates an error:

    >>> def wrap_error(say, msg):
    ...    1 / 0

Let's add this function and call `say` while capturing logs:

    >>> guild.plugin.listen_method(Hello.say, wrap_error)

    >>> log_capture = LogCapture()
    >>> with log_capture:
    ...   hello.say("And again!")
    I've wrapped 'And again!'
    I've also wrapped 'And again!'
    I've wrapped 'And again!' and prevented the original call!

Note the other three callbacks were called successfully.

Here's what was logged during that call:

    >>> log_capture.print_all()
    callback error
    Traceback (most recent call last):
    ...
    ZeroDivisionError: integer division or modulo by zero

We can remove wrappers using `remove_method_listener`:

    >>> guild.plugin.remove_method_listener(hello.say, wrap_and_prevent)
    >>> guild.plugin.remove_method_listener(hello.say, wrap_error)

    >>> hello.say("Again, once more!")
    I've wrapped 'Again, once more!'
    I've also wrapped 'Again, once more!'
    Again, once more!

Finally, we can remove all listeners on a method:

    >>> guild.plugin.remove_method_listeners(hello.say)
    >>> hello.say("Hello, without listeners!")
    Hello, without listeners!
