# Batch runs

These tests illustrate batch run behavior. We'll use the `batch`
sample project:

    >>> project = sample("projects", "batch")

We'll run everything in a temp Guild home:

    >>> guild_home = mkdtemp()

And a helper for running ops:

    >>> from guild import _api as gapi
    >>> def run(op, batches=None, **flags):
    ...   try:
    ...     output = gapi.run_capture_output(
    ...       op, cwd=project, flags=flags,
    ...       batch_files=batches, guild_home=guild_home)
    ...   except gapi.RunError as e:
    ...     print("ERROR (%i)" % e.returncode)
    ...     print(e.output)
    ...   else:
    ...     print(output.strip())

And a helper for listing runs:

    >>> from guild import cli
    >>> from guild.op_util import format_flag_val

    >>> def list_runs(**kw):
    ...   runs = gapi.runs_list(guild_home=guild_home, **kw)
    ...   table_data = []
    ...   flag_names = set()
    ...   for run in runs:
    ...     row_data = {"op": run.opref.to_opspec()}
    ...     table_data.append(row_data)
    ...     for name, val in run.get("flags", {}).items():
    ...       row_data[name] = "%s=%s" % (name, format_flag_val(val))
    ...       flag_names.add(name)
    ...   cli.table(table_data, ["op"] + sorted(flag_names))

And a helper to delete runs:

    >>> def delete_runs(runs=None):
    ...   gapi.runs_delete(runs, guild_home=guild_home)

We start with no runs:

    >>> list_runs()

## Batch runs

A batch run is a run that contains either explicit or implicit batch
specifiers.

Batch runs generate one or more trial runs.

There are two types of implicit batch specifiers:

- Flag list value
- A batch file

A flag list value indicates that the operation should be run each
value in the list. If there is more tha one flag with list values, the
operation is run over the catesian produce of all a possible flag
combinations.

A batch file may contain one or more flag combinations, each of which
is used to run the operation.

If both flag list values and batch files are used, the flag values are
applied to each flag combination in the batch files.

An explicit batch specifier is made using the `--optimizer` flag,
which indicates that the specified optimizer should be used to run the
operation multiple times with the goal of minimizing or maximizing an
operation result.

We'll look at each of these scanarios in the tests that follow.

## Baseline

We'll two operations to illustate various batch runs.

The first is the `say.py` script, which simply prints a specified
message, optionally capitalizing it.

    >>> run("say.py")
    hello

    >>> run("say.py", msg="hi")
    hi

    >>> run("say.py", msg="hi", loud="yes")
    HI

And our runs:

    >>> list_runs()
    say.py  loud=yes  msg=hi
    say.py  loud=no   msg=hi
    say.py  loud=no   msg=hello

TODO: show baseline for optimizing operation (e.g. copy over the
train.py op from the Guild optimizer example).

Let's delete our runs in preparation for the next section.

    >>> delete_runs()
    Deleted 3 run(s)

## Flag list values

A batch is run impicitly whenever a list of values is specified for a
flag.

Let's run `say.py` with a list of one `msg` flag value:

    >>> run("say.py", msg=["hi"])
    INFO: [guild] Running say.py (loud=no, msg=hi)
    hi

Here are the trial runs:

    >>> list_runs()
    say.py   loud=no  msg=hi
    +say.py

Note there are two runs. The first run, listed as `+say.py` (note the
leading plus sign), is the batch operation, which is separate from the
trial run.

The batch operation manages the trial runs. Failed batch operations,
for example, can be restarted by restarting the associated runs.

    >>> delete_runs()
    Deleted 2 run(s)

Next we'll run `say.py` with two values for `msg`:

    >>> run("say.py", msg=["hello", "hola"])
    INFO: [guild] Running say.py (loud=no, msg=hello)
    hello
    INFO: [guild] Running say.py (loud=no, msg=hola)
    hola

In this case, we have three runs, one for the batch and two for each
trial.

    >>> list_runs()
    say.py   loud=no  msg=hola
    say.py   loud=no  msg=hello
    +say.py

Here we we see that two trials are generated by the batch, each with
one of the specified `msg` flag values.

Trials are run in order corresponding to the flag value in the
list.

    >>> run("say.py", msg=["c", "a", "b"])
    INFO: [guild] Running say.py (loud=no, msg=c)
    c
    INFO: [guild] Running say.py (loud=no, msg=a)
    a
    INFO: [guild] Running say.py (loud=no, msg=b)
    b

We can specify other flags along with our batch specifiers:

    >>> run("say.py", msg=["a", "b"], loud="yes")
    INFO: [guild] Running say.py (loud=yes, msg=a)
    A
    INFO: [guild] Running say.py (loud=yes, msg=b)
    B

If we use multiple list values, trials are generated using the
cartesian product of all flag combinations. The order of trials
corresponds to the flag names in ascending order followed by the flag
values as ordered in each flag value list.

    >>> run("say.py", msg=["b", "a"], loud=["no", "yes"])
    INFO: [guild] Running say.py (loud=no, msg=b)
    b
    INFO: [guild] Running say.py (loud=no, msg=a)
    a
    INFO: [guild] Running say.py (loud=yes, msg=b)
    B
    INFO: [guild] Running say.py (loud=yes, msg=a)
    A

Let's delete our runs in preparation for the next section.

    >>> delete_runs()
    Deleted ... run(s)

## Batch files

Batch files are used to explicitly run batches. A batch file contains
one or more flag combinations that are each used to generate a trial
run.

Guild supports three batch file formats:

- YAML
- JSON
- CSV

Let's look at `batch.csv`, which we can use to run a batch:

    >>> cat(join_path(project, "batch.csv"))
    msg,loud
    hello 1
    hello 2,yes
    hello 3

CSV files must have a header row that defines the flag names separated
by commas. Each subsequent row is a list of flag values, each
corresponding to a flag name and also separate by commas.

In this case we have a batch of three flag combinations.

Let's use the batch file in an operation:

    >>> run("say.py", batches=["batch.csv"])
    INFO: [guild] Running say.py (loud=no, msg='hello 1')
    hello 1
    INFO: [guild] Running say.py (loud=yes, msg='hello 2')
    HELLO 2
    INFO: [guild] Running say.py (loud=no, msg='hello 3')
    hello 3

In cases where we explicitly define flag values, those flag values are
applied only if they are not defined in the batch file - the batch
file takes precedence over flags specified for the operation.

    >>> run("say.py", batches=["batch.csv"], loud="no")
    INFO: [guild] Running say.py (loud=no, msg='hello 1')
    hello 1
    INFO: [guild] Running say.py (loud=yes, msg='hello 2')
    HELLO 2
    INFO: [guild] Running say.py (loud=no, msg='hello 3')
    hello 3

We can additionally specify multiple flag values that are used to
generate additional trials, in cases where the batch file doesn't
specify a flag value.

Here we'll use a list of `loud`, which is applied in cases where
`loud` is not defined in the batch:

    >>> run("say.py", batches=["batch.csv"], loud=["yes", "no"])
    INFO: [guild] Running say.py (loud=yes, msg='hello 1')
    HELLO 1
    INFO: [guild] Running say.py (loud=no, msg='hello 1')
    hello 1
    INFO: [guild] Running say.py (loud=yes, msg='hello 2')
    HELLO 2
    INFO: [guild] Running say.py (loud=yes, msg='hello 3')
    HELLO 3
    INFO: [guild] Running say.py (loud=no, msg='hello 3')
    hello 3

Here's a case that further illustates the point. While we may request
different values for `msg`, the batch file values are used when
specified:

    >>> run("say.py", batches=["batch.csv"], msg=["hello 4", "hello 5"])
    INFO: [guild] Running say.py (loud=no, msg='hello 1')
    hello 1
    INFO: [guild] Running say.py (loud=yes, msg='hello 2')
    HELLO 2
    INFO: [guild] Running say.py (loud=no, msg='hello 3')
    hello 3

Next we'll look at `batch.yaml`:

    >>> cat(join_path(project, "batch.yaml"))
    - msg: hello 4
    - msg: hello 5
    - msg: hello 6
      loud: yes

In this case we have three flag batches as well, but with different
values.

Here's our batch using the file:

    >>> run("say.py", batches=["batch.yaml"])
    INFO: [guild] Running say.py (loud=no, msg='hello 4')
    hello 4
    INFO: [guild] Running say.py (loud=no, msg='hello 5')
    hello 5
    INFO: [guild] Running say.py (loud=yes, msg='hello 6')
    HELLO 6

We can apply a value for `loud` that will be used when the batch file
doesn't define it:

    >>> run("say.py", batches=["batch.yaml"], loud="yes")
    INFO: [guild] Running say.py (loud=yes, msg='hello 4')
    HELLO 4
    INFO: [guild] Running say.py (loud=yes, msg='hello 5')
    HELLO 5
    INFO: [guild] Running say.py (loud=yes, msg='hello 6')
    HELLO 6

Next we'll look at JSON formatted batch files.

    >>> cat(join_path(project, "batch.json"))
    [
      {"msg": "hello 7", "loud": false},
      {"msg": "hello 8", "loud": true},
      {"msg": "hello 9", "loud": true}
    ]

    >>> run("say.py", batches=["batch.json"])
    INFO: [guild] Running say.py (loud=no, msg='hello 7')
    hello 7
    INFO: [guild] Running say.py (loud=yes, msg='hello 8')
    HELLO 8
    INFO: [guild] Running say.py (loud=yes, msg='hello 9')
    HELLO 9

Finally, Guild supports multiple batch files, each of which being
applied in the order specified:

    >>> run("say.py", batches=["batch.csv", "batch.yaml", "batch.json"])
    INFO: [guild] Running say.py (loud=no, msg='hello 1')
    hello 1
    INFO: [guild] Running say.py (loud=yes, msg='hello 2')
    HELLO 2
    INFO: [guild] Running say.py (loud=no, msg='hello 3')
    hello 3
    INFO: [guild] Running say.py (loud=no, msg='hello 4')
    hello 4
    INFO: [guild] Running say.py (loud=no, msg='hello 5')
    hello 5
    INFO: [guild] Running say.py (loud=yes, msg='hello 6')
    HELLO 6
    INFO: [guild] Running say.py (loud=no, msg='hello 7')
    hello 7
    INFO: [guild] Running say.py (loud=yes, msg='hello 8')
    HELLO 8
    INFO: [guild] Running say.py (loud=yes, msg='hello 9')
    HELLO 9

Unsupported batch files generate an error:

    >>> run("say.py", batches=["batch.unknown"])
    ERROR (1)
    main_bootstrap.py: unsupported batch file extension for batch.unknown
    <BLANKLINE>
