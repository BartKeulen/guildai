# Run files

These tests examine the files generated by a run.

We'll generate runs in a temporary workspace:

    >>> workspace = mkdtemp()

And run operations from `batch` sample project:

    >>> project = sample("projects", "batch")

Some helper functions:

    >>> from guild import _api as gapi

    >>> def run(op, **flags):
    ...   out = gapi.run_capture_output(
    ...           op, cwd=project, guild_home=workspace,
    ...           flags=flags)
    ...   print(out.strip())

    >>> def list_runs():
    ...   return gapi.runs_list(guild_home=workspace)

    >>> def ls(run):
    ...    return find(run.path)

    >>> def cat_run_file(run, path):
    ...   cat(os.path.join(run.path, path))

## Normal runs

A simple run that prints a message:

    >>> run("say.py", msg="hi")
    hi

Our runs:

    >>> runs = list_runs()
    >>> len(runs)
    1

The files generated for our run:

    >>> first_run = runs[0]
    >>> first_run_files = ls(first_run)
    >>> first_run_files
    ['.guild/attrs/cmd',
     '.guild/attrs/compare',
     '.guild/attrs/deps',
     '.guild/attrs/env',
     '.guild/attrs/exit_status',
     '.guild/attrs/flags',
     '.guild/attrs/started',
     '.guild/attrs/stopped',
     '.guild/opdef.json',
     '.guild/opref',
     '.guild/output',
     '.guild/output.index']

Let's look at some of the generated files.

NOTE: We intentionally skip env, started, stopped, and output.index
files.

    >>> cat_run_file(first_run, ".guild/attrs/cmd")
    - ...
    - -u
    - /.../samples/projects/batch/say.py
    - --msg
    - hi

    >>> cat_run_file(first_run, ".guild/attrs/compare")
    - loss step as step
    - loss
    - acc
    - accuracy as acc
    - val_loss
    - val#loss as val_loss
    - val_acc
    - val#acc as val_acc

    >>> cat_run_file(first_run, ".guild/attrs/deps")
    {}

    >>> cat_run_file(first_run, ".guild/attrs/exit_status")
    0

    >>> cat_run_file(first_run, ".guild/attrs/flags")
    loud: false
    msg: hi

    >>> cat_run_file(first_run, ".guild/opdef.json")
    {"compare":
      ["loss step as step", "loss", "acc",
       "accuracy as acc", "val_loss",
       "val#loss as val_loss", "val_acc",
       "val#acc as val_acc"],
     "exec": "${python_exe} -u /.../samples/projects/batch/say.py ${flag_args}",
     "flags":
       {"loud": {"arg-switch": true, "default": false},
        "msg": {"default": "hello"}}}

    >>> cat_run_file(first_run, ".guild/opref")
    script:/.../samples/projects/batch/say.py ... '' say.py

    >>> cat_run_file(first_run, ".guild/output")
    hi

## Batch runs

Batch runs are normal runs and so have a similar list of
files. However, they also contain a `proto` run, which serves to
generate batch trials.

Let's run a batch operation to illustrate. We can indicate a run
should be a batch by specifying a list of values for a flag.

    >>> run("say.py", msg=["ho"])
    INFO: [guild] Running say.py (loud=no, msg=ho)
    ho

The batch generates two runs, one for the batch and the other for the
trial (the third run is from our previous test):

    >>> runs = list_runs()
    >>> len(runs)
    3

The latest run is the trial:

    >>> trial_run = runs[0]
    >>> trial_run.opref.op_name
    'say.py'

    >>> trial_run_files = ls(trial_run)
    >>> trial_run_files
    ['.guild/attrs/cmd',
     '.guild/attrs/compare',
     '.guild/attrs/deps',
     '.guild/attrs/env',
     '.guild/attrs/exit_status',
     '.guild/attrs/flags',
     '.guild/attrs/label',
     '.guild/attrs/started',
     '.guild/attrs/stopped',
     '.guild/opdef.json',
     '.guild/opref',
     '.guild/output',
     '.guild/output.index']

Note this is the same list as the first run, but with an additional
label attr:

    >>> trial_run_files_without_label = [
    ...   f for f in trial_run_files
    ...   if f != ".guild/attrs/label"]
    >>> trial_run_files_without_label == first_run_files
    True

The next run is the batch:

    >>> batch_run = runs[1]
    >>> batch_run.opref.op_name
    '+'

Its files:

    >>> ls(batch_run)
    ['.guild/attrs/cmd',
     '.guild/attrs/deps',
     '.guild/attrs/env',
     '.guild/attrs/exit_status',
     '.guild/attrs/flags',
     '.guild/attrs/started',
     '.guild/attrs/stopped',
     '.guild/opdef.json',
     '.guild/opref',
     '.guild/output',
     '.guild/output.index',
     '.guild/proto/.guild/PENDING',
     '.guild/proto/.guild/attrs/cmd',
     '.guild/proto/.guild/attrs/compare',
     '.guild/proto/.guild/attrs/flags',
     '.guild/proto/.guild/opdef.json',
     '.guild/proto/.guild/opref',
     '...']

Note the additional `proto` directory. This contains the prototype for
the `say.py` operation, which is used by the batch operation to
generate each specific trial op.

Note also the last entry '...' - this is the link to the trial run
directory.
