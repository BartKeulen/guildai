# Run files

These tests examine the files generated by a run.

We'll generate runs in a temporary workspace:

    >>> workspace = mkdtemp()

And run operations from `batch` sample project:

    >>> project = sample("projects", "batch")

Some helper functions:

    >>> from guild import _api as gapi

    >>> def run(op, **flags):
    ...   out = gapi.run_capture_output(
    ...           op, cwd=project, guild_home=workspace,
    ...           flags=flags)
    ...   print(out.strip())

    >>> def list_runs():
    ...   return gapi.runs_list(guild_home=workspace)

    >>> def ls(run):
    ...    return find(run.path)

    >>> def cat_run_file(run, path):
    ...   cat(os.path.join(run.path, path))

## Normal runs

A simple run that prints a message:

    >>> run("say.py", msg="hi")
    hi

Our runs:

    >>> runs = list_runs()
    >>> len(runs)
    1

The files generated for our run:

    >>> first_run = runs[0]
    >>> first_run_files = ls(first_run)
    >>> for file in first_run_files:
    ...    print(file) # doctest: +REPORT_UDIFF
    .guild/attrs/cmd
    .guild/attrs/compare
    .guild/attrs/deps
    .guild/attrs/env
    .guild/attrs/exit_status
    .guild/attrs/flags
    .guild/attrs/opdef
    .guild/attrs/run_params
    .guild/attrs/started
    .guild/attrs/stopped
    .guild/opref
    .guild/output
    .guild/output.index

Let's look at some of the generated files.

NOTE: We intentionally skip env, started, stopped, and output.index
files.

    >>> cat_run_file(first_run, ".guild/attrs/cmd")
    - ...
    - -um
    - guild.op_main
    - say
    - --msg
    - hi

    >>> cat_run_file(first_run, ".guild/attrs/compare")
    - loss step as step
    - loss
    - acc
    - accuracy as acc
    - val_loss
    - val#loss as val_loss
    - val_acc
    - val#acc as val_acc

    >>> cat_run_file(first_run, ".guild/attrs/deps")
    {}

    >>> cat_run_file(first_run, ".guild/attrs/exit_status")
    0

    >>> cat_run_file(first_run, ".guild/attrs/flags")
    loud: false
    msg: hi

    >>> cat_run_file(first_run, ".guild/opref")
    script:/.../samples/projects/batch/say.py ... '' say.py

    >>> cat_run_file(first_run, ".guild/output")
    hi

## Batch runs

Batch runs are normal runs and so have a similar list of
files. However, they also contain a `proto` run, which serves to
generate batch trials.

Let's run a batch operation to illustrate. We can indicate a run
should be a batch by specifying a list of values for a flag.

    >>> run("say.py", msg=["ho"])
    INFO: [guild] Running say.py (loud=no, msg=ho)
    ho

The batch generates two runs, one for the batch and the other for the
trial (the third run is from our previous test):

    >>> runs = list_runs()
    >>> len(runs)
    3

The latest run is the trial:

    >>> trial_run = runs[0]
    >>> trial_run.opref.op_name
    'say.py'

    >>> trial_run_files = ls(trial_run)
    >>> for file in trial_run_files:
    ...     print(file) # doctest: +REPORT_UDIFF
    .guild/attrs/batch
    .guild/attrs/cmd
    .guild/attrs/compare
    .guild/attrs/deps
    .guild/attrs/env
    .guild/attrs/exit_status
    .guild/attrs/flags
    .guild/attrs/label
    .guild/attrs/opdef
    .guild/attrs/run_params
    .guild/attrs/started
    .guild/attrs/stopped
    .guild/opref
    .guild/output
    .guild/output.index

The next run is the batch:

    >>> batch_run = runs[1]
    >>> batch_run.opref.op_name
    '+'

Its files:

    >>> for file in ls(batch_run):
    ...     print(file) # doctest: +REPORT_UDIFF
    .guild/attrs/cmd
    .guild/attrs/deps
    .guild/attrs/env
    .guild/attrs/exit_status
    .guild/attrs/flags
    .guild/attrs/opdef
    .guild/attrs/run_params
    .guild/attrs/started
    .guild/attrs/stopped
    .guild/opref
    .guild/output
    .guild/output.index
    .guild/proto/.guild/PENDING
    .guild/proto/.guild/attrs/cmd
    .guild/proto/.guild/attrs/compare
    .guild/proto/.guild/attrs/flags
    .guild/proto/.guild/attrs/opdef
    .guild/proto/.guild/attrs/run_params
    .guild/proto/.guild/opref
    .guild/trials
    ...

Note the additional `proto` directory. This contains the prototype for
the `say.py` operation, which is used by the batch operation to
generate each specific trial op.

Note also the last entry '...' - this is the link to the trial run
directory.
