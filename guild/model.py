# Copyright 2017 TensorHub, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import base64
import collections
import hashlib
import logging
import os
import sys

import pkg_resources

from guild import entry_point_util
from guild import modelfile
from guild import namespace
from guild import resource

_models = entry_point_util.EntryPointResources("guild.models", "model")

ModelRef = collections.namedtuple(
    "ModelRef", [
        "dist_type",
        "dist_name",
        "dist_version",
        "model_name"
    ])

class Model(object):

    def __init__(self, ep):
        self.name = ep.name
        self.dist = ep.dist
        self.modeldef = self._init_modeldef()
        self._fullname = None # lazy
        self._reference = None # lazy

    def __repr__(self):
        return "<%s.%s '%s'>" % (
            self.__class__.__module__,
            self.__class__.__name__,
            self.name)

    @property
    def fullname(self):
        if self._fullname is None:
            pkg_name = namespace.apply_namespace(self.dist.project_name)
            self._fullname = "%s/%s" % (pkg_name, self.name)
        return self._fullname

    @property
    def reference(self):
        if self._reference is None:
            self._reference = self._init_reference()
        return self._reference

    def _init_modeldef(self):
        raise NotImplementedError()

    def _init_reference(self):
        raise NotImplementedError()

class ModelfileModel(Model):
    """A model associated with a modelfile.

    These are generated from ModelfileDistribution instances
    (i.e. distributions that are derrived from modefiles).
    """

    def _init_modeldef(self):
        assert isinstance(self.dist, ModelfileDistribution), self.dist
        return self.dist.get_modeldef(self.name)

    def _init_reference(self):
        path = os.path.abspath(self.dist.modelfile.src)
        hash = self._modelfile_hash(path)
        return ModelRef("modelfile", path, hash, self.name)

    @staticmethod
    def _modelfile_hash(path):
        try:
            path_bytes = open(path, "rb").read()
        except IOError:
            logging.warning(
                "unable to read %s to calculate modelfile hash", path)
            return "-"
        else:
            return hashlib.md5(path_bytes).hexdigest()


class PackageModel(Model):
    """A model associated with a package.

    These are generated by Guild packages.
    """

    def _init_modeldef(self):
        modeldef = _find_dist_modeldef(self.name, self.dist)
        if modeldef is None:
            raise ValueError(
                "undefined model '%s' in %s" % (self.name, self.dist))
        return modeldef

    def _init_reference(self):
        pkg_name = namespace.apply_namespace(self.dist.project_name)
        return ModelRef(
            "project",
            pkg_name,
            self.dist.version,
            self.name)

def _find_dist_modeldef(name, dist):
    for modeldef in _ensure_dist_modeldefs(dist):
        if modeldef.name == name:
            return modeldef
    return None

def _ensure_dist_modeldefs(dist):
    if not hasattr(dist, "_modelefs"):
        dist._modeldefs = _load_dist_modeldefs(dist)
    return dist._modeldefs

def _load_dist_modeldefs(dist):
    modeldefs = []
    try:
        record = dist.get_metadata_lines("RECORD")
    except IOError:
        logging.warning(
            "distribution %s missing RECORD metadata - unable to find models",
            dist)
    else:
        for line in record:
            path = line.split(",", 1)[0]
            if os.path.basename(path) in modelfile.NAMES:
                fullpath = os.path.join(dist.location, path)
                _try_acc_modeldefs(fullpath, modeldefs)
    return modeldefs

def _try_acc_modeldefs(path, acc):
    try:
        models = modelfile.from_file(path)
    except Exception as e:
        logging.warning("unable to load models from %s: %s", path, e)
    else:
        for modeldef in models:
            acc.append(modeldef)

class ModelfileDistribution(pkg_resources.Distribution):

    def __init__(self, modelfile):
        super(ModelfileDistribution, self).__init__(
            modelfile.src, project_name=_modelfile_project_name(modelfile))
        self.modelfile = modelfile
        self._entry_map = _modelfile_entry_map(modelfile, self)

    def __repr__(self):
        return "<guild.model.ModelfileDistribution '%s'>" % self.modelfile.src

    def get_entry_map(self, group=None):
        if group is None:
            return self._entry_map
        else:
            return self._entry_map.get(group, {})

    def get_modeldef(self, name):
        for modeldef in self.modelfile:
            if modeldef.name == name:
                return modeldef
        raise ValueError(name)

def _modelfile_project_name(modelfile):
    """Returns a project name for a modelfile distribution.

    Modelfile distribution project names are of the format:

        '.modelfile.' + ESCAPED_MODELFILE_PATH

    ESCAPED_MODELFILE_PATH is a 'safe' project name (i.e. will not be
    modified in a call to `pkg_resources.safe_name`) that, when
    unescaped using `_unescape_project_name`, is the relative path of
    the directory containing the modelfile. The modefile name itself
    (e.g. 'MODEL' or 'MODELS') is not contained in the path.

    Modelfile paths are relative to the current working directory
    (i.e. the value of os.getcwd() at the time they are generated) and
    always start with '.'.
    """
    pkg_path = os.path.relpath(os.path.dirname(modelfile.src))
    if pkg_path[0] != ".":
        pkg_path = os.path.join(".", pkg_path)
    safe_path = _escape_project_name(pkg_path)
    return ".modelfile.%s" % safe_path

def _escape_project_name(name):
    """Escapes name for use as a valie pkg_resources project name."""
    return str(base64.b16encode(name.encode("utf-8")).decode("utf-8"))

def _unescape_project_name(escaped_name):
    """Unescapes names escaped with `_escape_project_name`."""
    return str(base64.b16decode(escaped_name).decode("utf-8"))

def _modelfile_entry_map(modelfile, dist):
    return {
        "guild.models": {
            model.name: _modelfile_model_entry_point(model, dist)
            for model in modelfile
        },
        "guild.resources": {
            res.fullname: _modelfile_resource_entry_point(res.fullname, dist)
            for res in _modelfile_resources(modelfile)
        }
    }

def _modelfile_model_entry_point(model, dist):
    return pkg_resources.EntryPoint(
        name=model.name,
        module_name='guild.model',
        attrs=('ModelfileModel',),
        dist=dist)

def _modelfile_resources(modelfile):
    for modeldef in modelfile:
        for res in modeldef.resources:
            yield res

class ModelfileResource(resource.Resource):

    def _init_resdef(self):
        assert isinstance(self.dist, ModelfileDistribution), self.dist
        model_name, res_name = _split_res_name(self.name)
        modeldef = self.dist.modelfile.get(model_name)
        assert modeldef, (self.name, self.dist)
        resdef = modeldef.get_resource(res_name)
        assert resdef, (self.name, self.dist)
        return resdef

def _split_res_name(name):
    parts = name.split(":", 1)
    if len(parts) != 2:
        raise ValueError("invalid resource name: %s" % name)
    return parts

class PackageModelResource(resource.Resource):

    def _init_resdef(self):
        model_name, res_name = _split_res_name(self.name)
        modeldef = _find_dist_modeldef(model_name, self.dist)
        if modeldef is None:
            raise ValueError(
                "undefined model '%s' in %s"
                % (model_name, self.dist))
        resdef = modeldef.get_resource(res_name)
        if resdef is None:
            raise ValueError(
                "undefined resource '%s%s' in %s"
                % (model_name, res_name, self.dist))
        return resdef

def _modelfile_resource_entry_point(name, dist):
    return pkg_resources.EntryPoint(
        name=name,
        module_name='guild.model',
        attrs=('ModelfileResource',),
        dist=dist)

class ModelImportError(ImportError):
    pass

class ModelImporter(object):

    def __init__(self, path):
        if not os.path.isdir(path):
            raise ModelImportError(path)
        path_names = os.listdir(path)
        for modelfile_name in modelfile.NAMES:
            if modelfile_name in path_names:
                break
        else:
            raise ModelImportError(path)

    @staticmethod
    def find_module(_fullname, _path=None):
        return None

def _model_finder(_importer, path, _only=False):
    try:
        models = modelfile.from_dir(path)
    except (IOError,
            modelfile.ModelfileFormatError,
            modelfile.ModelfileReferenceError) as e:
        logging.warning(
            "unable to load model from '%s': %s",
            path, e)
    else:
        yield ModelfileDistribution(models)

class ModelfileNamespace(namespace.PrefixNamespace):

    prefix = ".modelfile."

    @staticmethod
    def pip_info(_name):
        raise TypeError("modelfiles cannot be installed using pip")

    def package_name(self, project_name):
        pkg = super(ModelfileNamespace, self).package_name(project_name)
        parts = pkg.split("/", 1)
        decoded_project_name = _unescape_project_name(parts[0])
        rest = "/" + parts[1] if len(parts) == 2 else ""
        return decoded_project_name + rest

def get_path():
    return _models.path()

def set_path(path):
    _models.set_path(path)

def add_model_path(model_path):
    path = _models.path()
    try:
        path.remove(model_path)
    except ValueError:
        pass
    path.insert(0, model_path)
    _models.set_path(path)

def iter_models():
    for _name, model in _models:
        if not model.modeldef.private:
            yield model

def for_name(name):
    return _models.for_name(name)

def iter_():
    for _name, model in _models:
        if not model.modeldef.private:
            yield model

def _register_model_finder():
    sys.path_hooks.insert(0, ModelImporter)
    pkg_resources.register_finder(ModelImporter, _model_finder)

_register_model_finder()
